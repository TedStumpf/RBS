<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_ship_par</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input
var up = keyboard_check(ord('W'));
var down = keyboard_check(ord('S'));
var left = keyboard_check(ord('A'));
var right = keyboard_check(ord('D'));
var tm = 1;

var loc_max_speed = max_speed;
for (var i = 0; i &lt; instance_number(obj_speedzone); i++)    {
    var zone = instance_find(obj_speedzone, i);
    if (point_distance(x, y, zone.x, zone.y) &lt;= zone.lim_radius * meter_size)   {
        loc_max_speed = min(loc_max_speed, zone.lim_speed);
    }
}

if (phys_speed &gt; loc_max_speed) {
    up = false;
    down = true;
    tm = 5;
} else if (phys_speed == loc_max_speed)    {
    up = false;
}

if (up || down) {
    //  Parallel
    var thrust = dat_get_raw(equipped_engine, 'engine_thrust', 0) * dat_get_raw(equipped_ship, 'thrust_mult', 1);
    var acc = tm * thrust / dat_get_total_mass(equipped_ship, equipped_engine, equipped_power);
    var post = phys_speed + acc * (up - down) * dT;
    if ((phys_speed != loc_max_speed) &amp;&amp; (median(phys_speed, post, loc_max_speed) == loc_max_speed))   {
        phys_speed = loc_max_speed;
    }   else    {
        phys_speed = clamp(post, 0, max_speed);
    }
}

if (left || right)  {
    //  Rotational
    var thrust = dat_get_raw(equipped_engine, 'engine_rot', 0) * dat_get_raw(equipped_ship, 'handling_mult', 1);
    var rot = 60 * thrust / dat_get_total_mass(equipped_ship, equipped_engine, equipped_power);
    phys_dir += rot * (left - right) * dT;
    phys_dir = (phys_dir + 360) % 360;
    image_angle = phys_dir;
}

//  Update position
thrusting = (up &amp;&amp; !down);
stopping = ((down &amp;&amp; !up) &amp;&amp; (phys_speed &gt; 0));
event_inherited();

view_xview[0] = x - view_wview[0] / 2;
view_yview[0] = y - view_hview[0] / 2;
background_xscale[0] = view_wview[0] / view_wport[0];
background_yscale[0] = view_hview[0] / view_hport[0];
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw GUI
draw_sprite(spr_hud_lower_left, 0, 0, window_get_height());
draw_set_color(c_red);
draw_text(8, 8, string(fps));

//  Health
var xx = 20, mh = 160, p = my_internal / max_internal;
draw_set_colour(c_lime);
draw_hudbar(xx, mh, p);
//  Hull
xx = 40; p = my_hull / max_hull;
draw_set_colour(c_blue);
draw_hudbar(xx, mh, p);
//  Energy
xx = 60; p = my_elec / max_elec;
draw_set_colour(c_yellow);
draw_hudbar(xx, mh, p);
//  Heat
xx = 80; p = my_heat / max_heat;
draw_set_colour(c_red);
draw_hudbar(xx, mh, p);
//  Fuel
xx = 100; p = my_fuel / max_fuel;
draw_set_colour(c_orange);
draw_hudbar(xx, mh, p);

//  Speed (0 - 25)
xx = 130; p = clamp(phys_speed / 25, 0, 1);
draw_set_color(c_red);
draw_hudbar(xx, mh, p);

//  Speed (25 - 50)
xx = 150; p = clamp((phys_speed - 25) / 25, 0, 1);
draw_hudbar(xx, mh, p);

//  Speed (50 - 125)
xx = 170; mh = 150; p = clamp((phys_speed - 50) / 75, 0, 1);
draw_set_color(c_yellow);
draw_hudbar(xx, mh, p);

//  Speed (125 - 200)
xx = 190; p = clamp((phys_speed - 125) / 75, 0, 1);
draw_hudbar(xx, mh, p);

//  Speed (200 - 350)
xx = 210; mh = 140; p = clamp((phys_speed - 200) / 150, 0, 1);
draw_set_color(c_lime);
draw_hudbar(xx, mh, p);

//  Speed (350 - 500)
xx = 230; p = clamp((phys_speed - 350) / 150, 0, 1);
draw_hudbar(xx, mh, p);

//  Dynamic speed
draw_set_colour(c_aqua);
var base_speed = 500, speed_interval = (max_speed - base_speed) / 8;
for (var i = 0; i &lt; 8; i++) {
    var l_base = base_speed + speed_interval * i;
    xx += 20; mh -= 10;
    p = clamp((phys_speed - l_base) / speed_interval, 0, 1);
    draw_hudbar(xx, mh, p);
}

//draw_set_colour(c_red);
//draw_text(16, 16, string(phys_speed) + ", " + string(phys_dir));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
