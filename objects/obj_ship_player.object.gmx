<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_ship_par</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input
var up = keyboard_check(ord('W'));
var down = keyboard_check(ord('S'));
var left = keyboard_check(ord('A'));
var right = keyboard_check(ord('D'));

if (up || down) {
    //  Parallel
    var thrust = dat_get_raw(equipped_engine, 'engine_thrust', 0) * dat_get_raw(equipped_ship, 'thrust_mult', 1);
    var acc = thrust / dat_get_total_mass(equipped_ship, equipped_engine, equipped_power);
    phys_speed += acc * (up - down) * dT;
    phys_speed = clamp(phys_speed, 0, max_speed);
}

if (left || right)  {
    //  Rotational
    var thrust = dat_get_raw(equipped_engine, 'engine_rot', 0) * dat_get_raw(equipped_ship, 'handling_mult', 1);
    var rot = 60 * thrust / dat_get_total_mass(equipped_ship, equipped_engine, equipped_power);
    phys_dir += rot * (left - right) * dT;
    phys_dir = (phys_dir + 360) % 360;
    image_angle = phys_dir;
}

//  Update position
event_inherited();

var eng_count = dat_get_raw(equipped_ship, 'engine_points', 0);
for (var e = 0; e &lt; eng_count; e++)    {
    if (up &amp;&amp; !down)    {
        if (my_trail_fx[e] == noone)   {
            var e_color = dat_get_raw(equipped_engine, 'color', c_black);
            my_trail_fx[e] = instance_create(0, 0, obj_fx_trail);
            my_trail_fx[e].color = e_color;
        }
        var len = dat_get_raw(equipped_ship, 'engine_point_len_' + string(e), 0);
        var dir = dat_get_raw(equipped_ship, 'engine_point_dir_' + string(e), 0);
        var xx = x + lengthdir_x(len, dir + image_angle);
        var yy = y + lengthdir_y(len, dir + image_angle);
        
        trail_add_point(my_trail_fx[e], xx, yy, image_angle);
    }   else    {
        if (my_trail_fx[e] != noone)   {
            my_trail_fx[e].fade = true;
            my_trail_fx[e] = noone;
        }
    }
}

if (up &amp;&amp; !down)    {
    thruster_flame_size = 1;
}   else    {
    thruster_flame_size = max(0, thruster_flame_size - random(1) * 5 * dT);
}

view_xview[0] = x - view_wview[0] / 2;
view_yview[0] = y - view_hview[0] / 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw GUI
draw_sprite(spr_hud_lower_left, 0, 0, window_get_height());


//  Health
var xx = 20, mh = 160, p = my_internal / max_internal;
draw_set_colour(c_lime);
draw_hudbar(xx, mh, p);
//  Hull
xx = 40; p = my_hull / max_hull;
draw_set_colour(c_blue);
draw_hudbar(xx, mh, p);
//  Energy
xx = 60; p = my_elec / max_elec;
draw_set_colour(c_yellow);
draw_hudbar(xx, mh, p);
//  Heat
xx = 80; p = my_heat / max_heat;
draw_set_colour(c_red);
draw_hudbar(xx, mh, p);
//  Fuel
xx = 100; p = my_fuel / max_fuel;
draw_set_colour(c_orange);
draw_hudbar(xx, mh, p);

//  Speed (0 - 25)
xx = 130; p = clamp(phys_speed / 25, 0, 1);
draw_set_color(c_red);
draw_hudbar(xx, mh, p);

//  Speed (25 - 50)
xx = 150; p = clamp((phys_speed - 25) / 25, 0, 1);
draw_hudbar(xx, mh, p);

//  Speed (50 - 125)
xx = 170; mh = 150; p = clamp((phys_speed - 50) / 75, 0, 1);
draw_set_color(c_yellow);
draw_hudbar(xx, mh, p);

//  Speed (125 - 200)
xx = 190; p = clamp((phys_speed - 125) / 75, 0, 1);
draw_hudbar(xx, mh, p);

//  Speed (200 - 350)
xx = 210; mh = 140; p = clamp((phys_speed - 200) / 150, 0, 1);
draw_set_color(c_lime);
draw_hudbar(xx, mh, p);

//  Speed (350 - 500)
xx = 230; p = clamp((phys_speed - 350) / 150, 0, 1);
draw_hudbar(xx, mh, p);

//  Dynamic speed
draw_set_colour(c_aqua);
var base_speed = 500, speed_interval = (max_speed - base_speed) / 8;
for (var i = 0; i &lt; 8; i++) {
    var l_base = base_speed + speed_interval * i;
    xx += 20; mh -= 10;
    p = clamp((phys_speed - l_base) / speed_interval, 0, 1);
    draw_hudbar(xx, mh, p);
}

//draw_set_colour(c_red);
//draw_text(16, 16, string(phys_speed) + ", " + string(phys_dir));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
